# 8.3 Resolution Handling: 고해상도 이미지를 다루는 방법

VLM이 실제 세계의 다양한 이미지를 잘 처리하려면 **해상도(Resolution) 문제**를 잘 다루어야 함. 특히 OCR(문자 인식), 문서 이해, 세밀한 시각 분석 등의 태스크에서는 고해상도 이미지 처리가 필수적. 다양한 해상도 처리 전략과 그에 따른 트레이드오프.

---

## 1. 왜 해상도가 중요한가?

Vision Encoder(예: CLIP ViT-L/14)의 기본 입력은 224×224 또는 336×336 픽셀. 그런데 실제 사용 환경에서 이미지는 다양함:

- 스마트폰 사진: 4000×3000 픽셀
- 문서/영수증 스캔: 다양한 해상도, 세밀한 텍스트
- 인포그래픽: 긴 세로 형태, 많은 텍스트
- 의료 이미지: 고해상도, 세밀한 패턴

224×224로 강제 축소하면:
```
원본 문서 이미지 (1000×1414 픽셀)
    ↓ 리사이즈 (224×224)
픽셀이 7배 이상 압축됨 → 텍스트가 뭉개져서 판독 불가
```

이는 OCR과 문서 이해 성능을 크게 저하시킴. 따라서 **고해상도 처리 전략**이 필요함.

---

## 2. Fixed Resolution: 가장 단순한 접근

### 2.1 방법

모든 입력 이미지를 **고정된 크기로 리사이즈**함:

```
입력 이미지 (어떤 크기든)
    ↓ Resize (Bilinear/Bicubic 보간)
224×224 또는 336×336 픽셀
    ↓
Vision Encoder 입력
```

### 2.2 장점

- **구현이 매우 단순** — 배치 처리가 쉬움 (모든 이미지가 같은 크기)
- **일정한 토큰 수** — 항상 196개(14×14 패치) 또는 576개(24×24 패치) 토큰 생성
- **낮은 계산 비용** — LLM에 전달되는 시각 토큰 수가 고정

### 2.3 단점과 한계

**정보 손실**: 고해상도 이미지를 강제로 축소하면 세밀한 디테일이 사라짐.

```
영수증 이미지 예시:
- 원본: "상품명: 아메리카노  금액: ₩4,500"
- 224×224 축소 후: 텍스트가 너무 작아 ViT가 인식 불가
- 결과: VLM이 영수증의 내용을 정확히 읽지 못함
```

**Aspect Ratio 왜곡**: 가로-세로 비율이 다른 이미지를 정사각형으로 왜곡하면 물체의 형태가 변형됨:

```
원본: 16:9 영화 스틸컷 (와이드스크린)
    ↓ 224×224 강제 리사이즈
결과: 사람들이 세로로 찌그러진 모습
```

### 2.4 언제 사용?

- 프로토타입, 베이스라인 모델
- 고해상도 처리가 불필요한 태스크 (간단한 이미지 질문응답, 씬 이해)
- 자원이 제한된 환경 (Edge Device 등)

---

## 3. Dynamic Resolution: 원래 해상도 존중

### 3.1 개념

Dynamic Resolution 방식은 이미지를 미리 정해진 크기로 억지로 맞추지 않고, **이미지의 원래 해상도 또는 그에 가장 가까운 지원 해상도**로 처리함.

```
입력 이미지 (W × H)
    ↓
지원하는 해상도 집합에서 가장 가까운 것 선택
예: {224×224, 224×448, 448×224, 448×448, 672×336, ...}
    ↓
선택된 해상도로 약간의 리사이즈 (최소한의 왜곡)
    ↓
Vision Encoder 처리
```

### 3.2 Aspect Ratio Grouping (비율에 따른 그룹화)

배치 처리를 위해 비슷한 Aspect Ratio를 가진 이미지들을 같은 배치에 묶습니다:

```
배치 구성 예시:
- 가로형 이미지들 → 448×224 해상도 배치
- 세로형 이미지들 → 224×448 해상도 배치
- 정사각형 이미지들 → 336×336 해상도 배치
```

### 3.3 장점과 단점

**장점**
- Aspect Ratio 왜곡 최소화
- 다양한 이미지 유형에 더 잘 대응

**단점**
- 해상도별로 토큰 수가 달라짐 → 배치 처리 복잡화
- 지원하는 해상도를 미리 정해야 하는 제약

---

## 4. AnyRes: 타일링 기반 고해상도 처리

### 4.1 핵심 아이디어

LLaVA-NeXT(LLaVA-1.6이라고도 함)에서 도입된 AnyRes는 현재 가장 널리 사용되는 고해상도 처리 전략. 핵심 아이디어는:

1. 고해상도 이미지를 **기본 해상도(Base Resolution) 크기의 타일(Tile)**로 분할
2. 각 타일을 독립적으로 Vision Encoder로 처리
3. 전체 이미지를 축소한 **Global Thumbnail**도 함께 처리
4. 모든 타일의 토큰과 Thumbnail 토큰을 연결해 LLM에 전달

### 4.2 상세 과정

```
원본 이미지: 1344×336 픽셀 (와이드스크린)

Step 1: 타일 분할
  - 기본 해상도: 336×336
  - 이미지를 336×336 타일로 분할
  - 1344÷336 = 4개의 가로 타일, 336÷336 = 1개의 세로 타일
  - 총 4개 타일 (2×2 그리드)

  [Tile 1][Tile 2][Tile 3][Tile 4]

Step 2: 각 타일 독립 처리
  - 각 336×336 타일 → Vision Encoder → 576개 패치 토큰 (24×24 패치)
  - 4개 타일 → 4 × 576 = 2304개 토큰

Step 3: Global Thumbnail 처리
  - 원본 이미지를 336×336으로 축소 → Vision Encoder → 576개 토큰
  - 전체 구조와 맥락 정보 제공

Step 4: 토큰 연결
  - [Thumbnail 토큰 (576)] + [Tile 1 토큰 (576)] + ... + [Tile 4 토큰 (576)]
  - 총 5 × 576 = 2880개 시각 토큰 → LLM에 전달
```

### 4.3 AnyRes의 장점

**고해상도 정보 보존**: 각 타일이 원본 해상도에 가깝게 처리되므로 세밀한 텍스트와 디테일을 인식 가능

**전체 맥락 유지**: Global Thumbnail이 이미지의 전체 구조와 공간 관계를 제공

**기존 Vision Encoder 재활용**: 타일마다 같은 Vision Encoder를 사용하므로 추가 학습 없이 고해상도 처리 가능

```
AnyRes의 OCR 성능 향상 예시:
- Fixed 336×336: "인식 불가" (텍스트가 너무 작음)
- AnyRes (4타일): "아메리카노 ₩4,500" (정확히 인식)
```

### 4.4 토큰 수 관리

AnyRes의 단점은 토큰 수가 많아진다는 것임. 이를 관리하기 위해:

**Token Compression (압축)**: 각 타일의 토큰을 2×2 풀링으로 줄임:
- 576 토큰/타일 → 144 토큰/타일 (4배 압축)
- 4타일 + 1 Thumbnail = 5 × 144 = 720 토큰 (더 관리 가능)

**최대 타일 수 제한**: 예를 들어 최대 4×4=16타일로 제한

---

## 5. Multi-scale Patching: 여러 해상도 동시 처리

### 5.1 개념

Multi-scale Patching은 이미지를 **여러 해상도(Scale)에서 동시에 표현**해 각 스케일의 정보를 함께 활용함:

```
입력 이미지
    ├── Scale 1 (저해상도): 224×224 → 196 토큰 (전체 맥락)
    ├── Scale 2 (중해상도): 448×448 → 784 토큰 (중간 디테일)
    └── Scale 3 (고해상도): 896×896 → 3136 토큰 (세밀한 디테일)
         ↓
    각 스케일의 특징을 병합 또는 계층적으로 처리
```

### 5.2 CNN의 Feature Pyramid와 비교

CNN 기반 Object Detection에서 잘 알려진 FPN(Feature Pyramid Network)과 유사한 개념. FPN은 여러 스케일의 CNN Feature를 계층적으로 결합해 다양한 크기의 물체를 감지함.

ViT 기반에서는 이를 직접 구현하기가 복잡하므로, 실제로는 AnyRes처럼 타일링 방식이 더 많이 사용됩니다.

### 5.3 실용적 적용

- **InternVL** 시리즈: 동적 타일링 + 글로벌 특징을 결합하는 방식으로 멀티스케일 효과를 구현
- **Qwen2-VL**: 원래 해상도로 처리하되 토큰 수를 조절하는 방식

---

## 6. Token Pruning: 중복 토큰 제거

### 6.1 문제: 너무 많은 시각 토큰

고해상도 처리나 AnyRes를 적용하면 시각 토큰이 매우 많아집니다:

```
AnyRes (4타일, 압축 없음): 2304 + 576 = 2880 토큰
LLM의 일반적인 Context Length: 4096~8192 토큰
→ 시각 토큰만으로 Context의 35~70% 차지!
→ 텍스트를 위한 공간이 줄어들고 KV-Cache 메모리 급증
```

### 6.2 Token Pruning 방법들

**1) Attention Score 기반 Pruning**

시각 토큰의 중요도를 Attention Score로 측정해 낮은 점수의 토큰을 제거함:

```python
# 개념적 구현
attention_scores = compute_attention_from_text_to_visual(
    text_query, visual_keys
)  # 텍스트 쿼리가 각 시각 토큰에 얼마나 Attend하는지

# 중요도가 낮은 토큰 제거
threshold = 0.01
important_tokens = visual_tokens[attention_scores > threshold]
```

텍스트 쿼리와 관련이 없는 배경 부분의 토큰들이 주로 제거됩니다.

**2) Pooling 기반 Pruning**

인접한 토큰들을 평균 풀링으로 합칩니다:

```python
# 2×2 Average Pooling으로 토큰 수를 1/4로 줄임
# 576 패치 (24×24) → 144 패치 (12×12)
visual_tokens_pooled = avg_pool_2d(
    visual_tokens.reshape(24, 24, d_model),
    kernel_size=2, stride=2
)  # (12, 12, d_model) → 144 토큰
```

**3) 학습 기반 Token Selection**

별도의 작은 네트워크가 어떤 토큰이 중요한지 학습함. 예를 들어 Matryoshka Representation Learning 방식을 응용해 중요한 토큰이 앞에 오도록 순서를 정렬한 후 앞부분만 사용함.

### 6.3 Pruning의 트레이드오프

```
더 많은 토큰 유지          토큰 Pruning 적용
        ↕                           ↕
세밀한 정보 보존           LLM 처리 속도 향상
더 나은 OCR 성능           KV-Cache 메모리 절약
높은 계산 비용             일부 정보 손실
```

태스크에 따라 적절한 균형점을 선택해야 함:
- OCR, 문서 이해: 토큰을 최대한 보존
- 일반 VQA: 적극적인 Pruning 가능

---

## 7. Aspect Ratio Preservation: 왜곡 없이 처리하기

### 7.1 왜곡의 문제

이미지를 정사각형으로 강제 변환하면 다양한 문제가 발생합니다:

```
원본 (16:9 와이드스크린 스포츠 이미지)
    ↓ 224×224 강제 변환
결과: 농구 선수의 키가 160cm처럼 보임 (세로로 압축)
→ 모델이 잘못된 물체 형태를 학습

원본 (세로형 초상화 사진)
    ↓ 224×224 강제 변환
결과: 사람 얼굴이 가로로 납작하게 왜곡
→ 얼굴 인식 성능 저하
```

### 7.2 Padding을 통한 Aspect Ratio 유지

**Zero Padding (Zero-padding)**:

```
원본: 4:3 이미지 (400×300)
    ↓ 목표 크기: 336×336

접근 A: 강제 리사이즈 (왜곡)
  - 400×300 → 336×336 (세로 방향 10% 확장)

접근 B: 비율 유지 + 패딩
  - 400×300을 비율 유지하며 축소: 336×252
  - 위아래에 42픽셀씩 검은색 패딩 추가
  - 결과: 336×336 (비율 유지, 왜곡 없음)

┌────────────────────────────┐
│        (검은 패딩)         │ ← 42px
├────────────────────────────┤
│                            │
│       실제 이미지          │ 252px
│       (336×252)            │
│                            │
├────────────────────────────┤
│        (검은 패딩)         │ ← 42px
└────────────────────────────┘
   ←──────── 336px ────────→
```

**단점**: 패딩 영역이 불필요한 토큰을 생성하고, 모델이 패딩의 의미를 학습해야 함.

### 7.3 Native Resolution Grids

더 스마트한 방법은 이미지의 Aspect Ratio에 맞는 **그리드(Grid)**를 선택하는 것:

```
이미지가 16:9라면:
- 가능한 그리드: 4×2 타일 (4개 가로 × 2개 세로)
- 각 타일: 336×336 → 총 입력: 1344×672

이미지가 1:3이라면 (세로 긴 문서):
- 가능한 그리드: 1×3 타일 (1개 가로 × 3개 세로)
- 각 타일: 336×336 → 총 입력: 336×1008
```

이렇게 하면 패딩 없이 이미지의 자연스러운 Aspect Ratio를 유지할 수 있음.

### 7.4 OCR과 문서 이해에서의 중요성

Aspect Ratio 유지는 다음 태스크에서 특히 중요합니다:

**OCR (광학 문자 인식)**:
- 글자의 형태가 왜곡되면 인식 정확도가 급감
- "1"과 "l", "0"과 "O" 같은 유사 문자 구분에 픽셀 수준의 정밀도 필요

**문서 이해**:
- 표(Table)의 행과 열 구조가 왜곡되면 관계 파악 어려움
- 수식(Formula)의 위첨자/아래첨자 위치가 중요

**차트/그래프 이해**:
- 축의 비율이 달라지면 데이터 해석이 틀릴 수 있음

---

## 8. 해상도 처리 전략 종합 비교

| 전략 | 토큰 수 | OCR 성능 | 왜곡 | 계산 비용 | 구현 복잡도 |
|------|--------|----------|------|----------|------------|
| **Fixed Resolution** | 낮음 (고정) | 낮음 | 있음 | 낮음 | 낮음 |
| **Dynamic Resolution** | 중간 (가변) | 중간 | 없음 | 중간 | 중간 |
| **AnyRes** | 높음 (가변) | 높음 | 없음 | 높음 | 중간 |
| **Multi-scale** | 매우 높음 | 매우 높음 | 없음 | 매우 높음 | 높음 |
| **AnyRes + Pruning** | 중간 (조절 가능) | 높음 | 없음 | 중간 | 높음 |

---

## 9. 실제 모델에서의 해상도 처리

| 모델 | 해상도 전략 | 최대 해상도 | 시각 토큰 수 |
|------|-----------|-----------|------------|
| **LLaVA v1** | Fixed 224×224 | 224×224 | 256 |
| **LLaVA-1.5** | Fixed 336×336 | 336×336 | 576 |
| **LLaVA-NeXT** | AnyRes | 1344×1344 | ~2880 |
| **InternVL 2.5** | Dynamic Tiling | 4096×4096 | ~최대 수천 |
| **Qwen2-VL** | Native Resolution | 임의 | M-RoPE로 동적 처리 |
| **GPT-4V** | 미공개 (타일링 추정) | ~2048×2048 | 미공개 |

---

## 핵심 용어 정리

| 용어 | 설명 |
|------|------|
| **Fixed Resolution** | 모든 이미지를 고정 크기로 리사이즈 |
| **Dynamic Resolution** | 이미지 원래 해상도 또는 가장 가까운 지원 해상도 사용 |
| **AnyRes** | 이미지를 타일로 분할 + 글로벌 썸네일 처리 방식 |
| **Tile** | AnyRes에서 이미지를 분할하는 기본 단위 |
| **Global Thumbnail** | AnyRes에서 이미지 전체를 축소한 저해상도 버전 |
| **Token Pruning** | 중복된 시각 토큰을 제거해 시퀀스 길이를 줄이는 방법 |
| **Aspect Ratio** | 이미지의 가로-세로 비율 |
| **Zero Padding** | 이미지를 왜곡 없이 목표 크기로 맞추기 위해 빈 공간을 채우는 방법 |
| **Multi-scale Patching** | 여러 해상도에서 동시에 이미지를 표현하는 방법 |
| **OCR** | Optical Character Recognition, 이미지에서 텍스트를 인식하는 기술 |
| **Native Resolution** | 이미지의 원래 해상도, 리사이즈 없이 그대로 사용 |
